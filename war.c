#include <stdio.h>
#include <string.h>
#include <stdlib.h> // Biblioteca pad√£o: Fun√ß√µes de aloca√ß√£o de mem√≥ria
#include <time.h> // Biblioteca de tempo: Fun√ß√µes para data, hora e inicializa√ß√£o de aleat√≥riedade (srand)

// ==============================
// Estrutura do Territ√≥rio
// ==============================
typedef struct {
    char nome[30];
    char cor[10];
    int tropas;
} Territorio;

// ==============================
// Fun√ß√£o: cadastrarTerritorios
// Cadastra os territ√≥rios dinamicamente
// ==============================
void cadastrarTerritorios(Territorio* mapa, int qtd){
    for (int i = 0; i < qtd; i++){
        printf("\n--- Cadastro de Territ√≥rio %d ---\n", i + 1);

        printf("Nome do Territ√≥rio: ");
        fgets(mapa[i].nome, sizeof(mapa[i].nome), stdin);
        mapa[i].nome[strcspn(mapa[i].nome, "\n")] = 0;

        printf("Cor do ex√©rcito: ");
        fgets(mapa[i].cor, sizeof(mapa[i].cor), stdin);
        mapa[i].cor[strcspn(mapa[i].cor, "\n")] = 0;

        printf("N√∫mero de Tropas: ");
        scanf("%d", &mapa[i].tropas);
        getchar();
    }
}

// ==============================
// Fun√ß√£o: exibirMapa
// Exibe o estado atual do territ√≥rio
// ==============================
void exibirMapa(Territorio* mapa, int qtd){
    printf("\n==============================\n");
    printf("     ESTADO ATUAL DO MAPA üó∫Ô∏è\n");
    printf("==============================\n");
    for (int i = 0; i < qtd; i++) {
        printf("\nTerrit√≥rio %d:\n", i + 1);
        printf("   Nome: %s\n", mapa[i].nome);
        printf("   Cor: %s\n", mapa[i].cor);
        printf("   Tropas: %d\n", mapa[i].tropas);
    }
}

// ==============================
// Fun√ß√£o: atacar
// imula um ataque entre dois territ√≥rio
// ==============================
void atacar(Territorio* atacante, Territorio* defensor) {
    // Verifica se n√£o √© ataque contra territ√≥rio pr√≥prio
    if (strcmp(atacante->cor, defensor->cor) == 0) {
        printf("\n‚ö†Ô∏è  Voc√™ n√£o pode atacar um territ√≥rio da sua pr√≥pria cor!\n");
        return;
    }

    // Verifica se o territ√≥rio atacante tem tropas suficientes
    if (atacante->tropas < 2) {
        printf("\n‚ö†Ô∏è  O territ√≥rio atacante precisa ter pelo menos 2 tropas!\n");
        return;
    }

    // Rolagem dos dados
    printf("\nüé≤ Rolando os dados...\n");
    int dadoAtacante = rand() % 6 + 1;
    int dadoDefensor = rand() % 6 + 1;

    printf("  Dado do atacante: %d\n", dadoAtacante);
    printf("  Dado do defensor: %d\n", dadoDefensor);

    // Vit√≥ria do atacante ou empate (empates favorecem atacante)
    if (dadoAtacante >= dadoDefensor) {
        printf("\nüî• O atacante venceu a batalha!\n");

        if (defensor->tropas == 1) {
            // √öltima tropa do defensor: conquista total
            printf("üè¥‚Äç‚ò†Ô∏è Territ√≥rio conquistado!\n");
            defensor->tropas = 1;            // Deixa 1 tropa do atacante no territ√≥rio conquistado
            atacante->tropas -= 1;           // Remove tropa que foi para o novo territ√≥rio
            strcpy(defensor->cor, atacante->cor); // Atualiza a cor do territ√≥rio conquistado
        } else {
            // Defensor ainda tem tropas: perde apenas 1 tropa
            defensor->tropas -= 1;
            printf("üí• O defensor perdeu 1 tropa! Tropas restantes: %d\n", defensor->tropas);
        }
    } else {
        // Defesa bem-sucedida
        printf("\nüí™ O defensor resistiu ao ataque.\n");
        atacante->tropas -= 1;               // Atacante perde 1 tropa
        printf("‚öîÔ∏è O atacante perdeu 1 tropa. Tropas restantes: %d\n", atacante->tropas);
    }
}


// ==============================
// Fun√ß√£o: liberarMemoria
// Libera os espa√ßo alocado dinamicamente
// ==============================
void liberarMemoria(Territorio* mapa){
    free(mapa);
}

// ==============================
// Fun√ß√£o: Principal
// ==============================
int main() {
    srand(time(NULL)); // Aleat√≥riedade

    int qtd;
    printf("Quantos territ√≥rios deseja cadastrar? ");
    scanf("%d", &qtd);
    getchar();

    // Aloca√ß√£o do vetor de territ√≥rios
    Territorio* mapa = (Territorio*) calloc(qtd, sizeof(Territorio));
    if (mapa == NULL) {
        printf("Erro ao alocar mam√≥ria!\n");
        return 1;
    }
    
    // Cadastro
    cadastrarTerritorios(mapa, qtd);

    int opcao;
    do {
        exibirMapa(mapa, qtd);
        printf("\nO que deseja fazer?\n");
        printf("1 - Atacar\n");
        printf("2 - sair\n");
        printf("Escolha: ");
        scanf("%d", &opcao);
        getchar();

        if (opcao == 1) {
            int iAtacante, iDefensor;

            printf("\nEscolha o n√∫mero do territ√≥rio atacante üó°Ô∏è: ");
            scanf("%d", &iAtacante);
            getchar();

            printf("Escolha o n√∫mero do territ√≥rio defensor üõ°Ô∏è: ");
            scanf("%d", &iDefensor);
            getchar();

            if (iAtacante < 1 || iAtacante > qtd || iDefensor < 1 || iDefensor > qtd) {
                printf("\n‚ö†Ô∏è √çndices invalidos!\n");
            } else {
                atacar(&mapa[iAtacante - 1], &mapa[iDefensor - 1]);
            }
        }
    } while (opcao != 2);
    liberarMemoria(mapa);
    printf("\nMem√≥ria liberada. Fim de Jogo!\n");
    
    return 0;
}
